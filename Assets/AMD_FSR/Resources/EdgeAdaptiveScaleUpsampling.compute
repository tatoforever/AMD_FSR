#pragma kernel KMain
#pragma kernel KInitialize

//#pragma multi_compile _ _ALPHA
#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#define A_GPU 1
#define A_HLSL 1
#define FSR_EASU_F 1

#include "ffx_a.hlsl"

// 4 elements:
// [0] = const0
// [1] = const1
// [0] = const2
// [1] = const3
// ComputeBuffer is allocated with stride sizeof(int)*4, 4 elements

RWStructuredBuffer<uint4> _EASUParameters;

float4 _EASUViewportSize;
float4 _EASUInputImageSize;
float4 _EASUOutputSize;

SamplerState s_linear_clamp_sampler;
Texture2D<AF4> InputTexture;
RWTexture2D<AF4> OutputTexture;

AF4 FsrEasuRF(AF2 p) { AF4 res = InputTexture.GatherRed(s_linear_clamp_sampler, p, ASU2(0, 0)); return res; }
AF4 FsrEasuGF(AF2 p) { AF4 res = InputTexture.GatherGreen(s_linear_clamp_sampler, p, ASU2(0, 0)); return res; }
AF4 FsrEasuBF(AF2 p) { AF4 res = InputTexture.GatherBlue(s_linear_clamp_sampler, p, ASU2(0, 0)); return res; }

#include "ffx_fsr1.hlsl"
//#include "UnityCG.cginc"

void Upscale(AU2 pos) {
    AF3 c;
    FsrEasuF(c.rgb, pos, _EASUParameters[0], _EASUParameters[1], _EASUParameters[2], _EASUParameters[3]);
    //OutputTexture[pos] = AF4(LinearToGammaSpace(c), 1);
    OutputTexture[pos] = AF4(c, 1);
}

//Main
[numthreads(64, 1, 1)]
void KMain(uint3 LocalThreadId : SV_GroupThreadID, uint3 WorkGroupId : SV_GroupID, uint3 dispatchThreadId : SV_DispatchThreadID)
{
    //UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);//we dont need this, we are only rendering to 1 screen

    // Do remapping of local xy in workgroup for a more PS-like swizzle pattern.
    AU2 gxy = ARmp8x8(LocalThreadId.x) + AU2(WorkGroupId.x<<3u, WorkGroupId.y<<3u);

#ifdef _ALPHA
    float2 uv = ((float2)gxy.xy + 0.5) * _EASUOutputSize.zw;    
    //float alpha = SAMPLE_TEXTURE2D_X_LOD(InputTexture, s_linear_clamp_sampler, ClampAndScaleUVForBilinear(uv), 0.0).a;
    float alpha = InputImage.SampleLevel(s_linear_clamp_sampler, ClampAndScaleUVForBilinear(uv), 0).a;
#else
    float alpha = 1.0;
#endif

    // AU4 con0 = _EASUParameters[0];
    // AU4 con1 = _EASUParameters[1];
    // AU4 con2 = _EASUParameters[2];
    // AU4 con3 = _EASUParameters[3];
    // AF4 c;
    //
    // FsrEasuF(c.rgb, gxy, con0, con1, con2, con3);

    //Input always as sqrt of color.
    //c.rgb *= c.rgb;

    // c.rgb = LinearToGammaSpace(c.rgb);
    // c.a = alpha;
    // OutputTexture[gxy] = c;

    Upscale(gxy);
    // gxy.x += 8u;
    // Upscale(gxy);
    // gxy.y += 8u;
    // Upscale(gxy);
    // gxy.x -= 8u;
    // Upscale(gxy);
}

//Init
[numthreads(1,1,1)]
void KInitialize()
{
    AU4 con0 = (AU4)0;
    AU4 con1 = (AU4)0;
    AU4 con2 = (AU4)0;
    AU4 con3 = (AU4)0;
    FsrEasuCon(con0,con1,con2,con3,
        _EASUViewportSize.x,  _EASUViewportSize.y,
        _EASUInputImageSize.x,_EASUInputImageSize.y,
        _EASUOutputSize.x,    _EASUOutputSize.y);

    _EASUParameters[0] = con0;
    _EASUParameters[1] = con1;
    _EASUParameters[2] = con2;
    _EASUParameters[3] = con3;
}